<!DOCTYPE html>
<html lang="en">

    <!-- This is an automagically generated document! -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=large, initial-scale=1.0">
    <title>The Dogeforce Project</title>
    <link rel="shortcut icon" type="image/png" href="/images/icon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/design-system/2.12.1/styles/salesforce-lightning-design-system.min.css">
    <link rel="stylesheet" href="/css/site.css">

    <!-- header -->
    <div class="slds-container slds-theme_default">
        <div class="slds-grid slds-p-bottom_large">
            <div class="slds-col slds-size_1-of-6">
                <div class="slds-m-left_medium slds-text-align_center">
                    <p>
                        <img src="/images/logo.png" class="dgf-logo">
                    </p>
                    <p class="slds-text-heading_large">
                        <a href="/">Dogeforce</a>
                    </p>
                </div>
            </div>
            <div class="slds-col slds-size_4-of-6">

            </div>
            <div class="slds-col slds-size_1-of-6">
                <div class="slds-m-around_large">
                    <a href="https://discord.gg/6eQFVUv">
                        <button class="slds-button slds-button_neutral">
                            SFXD's Discord
                        </button>
                    </a>
                </div>
            </div>
        </div>
    </div>

</head>

<body>
    <div class="slds-container slds-theme_default slds-border_top dgf-body">

        <div class="slds-grid">

            <!-- sidebar -->
            <div class="slds-border_right slds-col slds-size_1-of-6">
                
    <ol class="slds-has-block-links_space">
    
    <li class="slds-item">
        <a href="/projects/declarative-rollup-summaries-for-lookups.html">Declarative Rollup Summaries for Lookups</a>
    </li>
    
    <li class="slds-item">
        <a href="/projects/mass-action-scheduler.html">Mass Action Scheduler</a>
    </li>
    
    <li class="slds-item">
        <a href="/projects/dogeforce-s-website-this-site.html">Dogeforce's Website (this site!)</a>
    </li>
    
</ol>

            </div>

            <!-- content -->
            <div class="slds-grid slds-p-left_small slds-p-right_small slds-col slds-size_4-of-6">

                

<div>
    <div class="slds-m-top_medium">
        <div class="slds-text-heading_large ">Salesforce’s Apex does not support the PATCH method. What to do if I need to call an endpoint with PATCH?</div>
        <div class="slds-text-heading_medium">by @renatoliveira</div>
        <div class="slds-m-top_small">when: 2020-12-25</div>
    </div>
    <div class="slds-m-top_large">
        <p class="slds-m-bottom_medium">I had a requirement once. A proof of concept. I needed to call a Microsoft Azure endpoint from Salesforce using the PATCH HTTP verb. The problem is, as mentioned in the title, that Apex does not support this verb.</p>
<p class="slds-m-bottom_medium">If we are trying to call a Salesforce endpoint, there’s a trick: append <code>?_HttpMethod=PATCH</code> to the end of the URL. This is a workaround that Salesforce. This doesn’t help us because we are not calling a Salesforce endpoint. Another workaround would be setting the X-HTTP-Method-Override as PATCH in the request’s header. This is a convention that some servers follow, but this does not guarantee that the server being called will accept our request as a patch.
Let’s write a simple proxy that is hosted on Heroku!</p>
<p class="slds-m-bottom_medium">Leveraging a Heroku app in another cloud (technically another Salesforce cloud since 2010) we are able to forward our request to its final destination.</p>
<blockquote class="slds-border_left slds-p-left_small">
<ol>
<li>Salesforce calls our Heroku app endpoint</li>
<li>The app forwards the request with the correct verb</li>
<li>The app receives the response from Azure and forwards it back to Salesforce</li>
</ol>
</blockquote>
<p class="slds-m-bottom_medium">To do that, I’m going to use Python with the Flask and requests libraries. Flask will handle the “web app” part, while requests is going to be used to forward our request.</p>
<p class="slds-m-bottom_medium">NOTE: I am not going to cover the part where we get Azure’s access token because that doesn’t involve an unsupported verb.</p>
<p class="slds-m-bottom_medium">Assuming that our Salesforce code will send a request with the access token, the payload and the target URL, it will probably look like this:</p>
<pre><code>{
    "token": "V2VsbCBhcmVuJ3QgeW91IGN1cmlvdXM/DQoNCiBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LiBOdWxsYW0gcGVsbGVudGVzcXVlIHRvcnRvciBhYyBlbmltIGxhb3JlZXQsIGFjIGVsZW1lbnR1bSB0dXJwaXMgdWx0cmljaWVzLiBJbnRlZ2VyIGludGVyZHVtIHJpc3VzIGxhY3VzLCBlZ2V0IGNvbnNlcXVhdCBsaWd1bGEgZmVybWVudHVtIHZpdGFlLiBFdGlhbSBzb2RhbGVzLCBsaWJlcm8gdml0YWUgZGlnbmlzc2ltIGx1Y3R1cywgbGliZXJvIGFyY3UgdnVscHV0YXRlIHF1YW0sIGF0IG1hdHRpcyBkdWkgbWFnbmEgbmVjIG1hc3NhLiBEb25lYyBpcHN1bSBkb2xvciwgZnJpbmdpbGxhIHZpdGFlIG5pYmggYXQsIHJob25jdXMgc2NlbGVyaXNxdWUgZXN0LiBEb25lYyBuZWMgc29kYWxlcyByaXN1cy4gUGVsbGVudGVzcXVlIHF1aXMgZnJpbmdpbGxhIGVyb3MuIFBlbGxlbnRlc3F1ZSBoYWJpdGFudCBtb3JiaSB0cmlzdGlxdWUgc2VuZWN0dXMgZXQgbmV0dXMgZXQgbWFsZXN1YWRhIGZhbWVzIGFjIHR1cnBpcyBlZ2VzdGFzLiBOYW0gcnV0cnVtIG1ldHVzIG1hdXJpcywgYWMgdWxsYW1jb3JwZXIgdGVsbHVzIGF1Y3RvciBpbi4gVXQgYWNjdW1zYW4gc2NlbGVyaXNxdWUgc29kYWxlcy4gRnVzY2UgdmFyaXVzIG5lcXVlIGVzdCwgc2VkIHB1bHZpbmFyIHNlbSBzY2VsZXJpc3F1ZSBub24uIA==",
    "payload": "IFNlZCB2ZW5lbmF0aXMgZXQgbWV0dXMgbm9uIGx1Y3R1cy4gUGVsbGVudGVzcXVlIGFjIGV1aXNtb2QgbWV0dXMsIG5lYyB0ZW1wb3IgZHVpLiBOYW0gYSB2ZXN0aWJ1bHVtIGZlbGlzLiBOdW5jIG1hZ25hIGxpZ3VsYSwgY29uZ3VlIG5lYyBpbXBlcmRpZXQgdXQsIGNvbmd1ZSB2dWxwdXRhdGUgcXVhbS4gTWFlY2VuYXMgYmxhbmRpdCwgZmVsaXMgbmVjIHNlbXBlciBkYXBpYnVzLCB0ZWxsdXMgaXBzdW0gdm9sdXRwYXQgYXVndWUsIGFjIGVnZXN0YXMgbmlzbCBvcmNpIG5lYyBzYXBpZW4uIEV0aWFtIGEgdnVscHV0YXRlIGVyb3MuIEN1cmFiaXR1ciBsYWNpbmlhIHNjZWxlcmlzcXVlIG5pc2wgc2VkIHZvbHV0cGF0LiBNYXVyaXMgdml0YWUgZXJhdCBwZWxsZW50ZXNxdWUsIGxhY2luaWEgdHVycGlzIHV0LCB0ZW1wb3Igc2FwaWVuLiBJbnRlZ2VyIHZlbCBsb2JvcnRpcyBkdWkuIEN1cmFiaXR1ciBpbXBlcmRpZXQgbWF0dGlzIGZlbGlzLiBQaGFzZWxsdXMgY29tbW9kbyBtYXNzYSBldSB2ZWxpdCBkYXBpYnVzIHRyaXN0aXF1ZSBhIGV1IGxpYmVyby4gRnVzY2UgaW4gcmlzdXMgZW5pbS4gRnVzY2UgZmVybWVudHVtIGV0IHB1cnVzIGV0IGNvbmRpbWVudHVtLiBJbiBzY2VsZXJpc3F1ZSBwb3N1ZXJlIGVsaXQsIHZpdGFlIGludGVyZHVtIHR1cnBpcyBjb25zZWN0ZXR1ciBhdC4g",
    "url": "https://outlook.office.com/api/beta/me/contacts/31d14663-8cf4-4acf-b1c8-556b8e62107d"
}
</code></pre>
<p class="slds-m-bottom_medium">The app will receive this and interpret it as “okay, I’ve got this encoded payload, and I shall use this token to send it to this endpoint”:</p>
<pre><code># Import the required libraries
# Flask is the web framework for dealing with web stuff (such as serving the app and handling
# the connections) We need to import the main "Flask" to run the app, and also its
# request and Response method and class to handle the request properly
from flask import Flask, Response, request

# requests is a simple http request library to handle... requests.
import requests

# Base64 is a standard module to help us encode/decode Base 64 strings
import base64
# Json is a standar dmodule to help us handle JSON in Python (converting it from/to
# dictionaries - which are also known as maps in some other languages)
import json
# OS is a standard module to handle dealing with the OS directly (we use it just to check
# an environment variable at the end of the script)
import os


# Lets first create the app. This is an empty app which does nothing.
# The app will do what we want as we define the methods/routes below, with (for example)
# the `app.route` decorator (which specifies the route and allowed methods)
app = Flask(__name__)

# This route defines that the app can receive POST requests in the `/contact/` endpoint. So
# when deployed, if the app is named `quiet-waters-12345`, its Heroku URL will be
# `https://quiet-waters-12345.herokuapp.com/` and we should hit that endpoint, adding the
# `/contact/` at the end.
@app.route('/contact/', methods=['POST'])
def contact():
    # First lets deserialize the request's JSON data into a dictionary.
    request_data = request.get_json()

    # We check if there are the required attributes we need
    if 'token' in request_data and 'payload' in request_data and 'url' in request_data:
        try:
            # We try to decode the payload
            payload = base64.b64decode(request_data['payload']).decode('utf-8')

            # Assign the original payload to a new attribute named `original_payload`
            # in our dictionary
            request_data['original_payload'] = payload

            # Define the headers as required by the Azure endpoint
            headers = {
                'Authorization': 'Bearer ' + request_data['token'],
                'Content-Type': 'application/json'
            }

            # Try to call external endpoint using the requests library. Note that we
            # use the `patch` method here.
            azure_request = requests.patch(
                url=request_data['url'],
                data=payload,
                headers=headers
            )
            # When the request is finished, its result is stored in `azure_request`,
            # which we can use to get the JSON response.
            result = {
                "azure_response": azure_request.json()
            }
            # We basically dump the request's result into a new Response and we return
            # it to the service who called us in the first place.
            resp = Response(json.dumps(result), status=azure_request.status_code, mimetype='applcation/json')
            return resp
        except Exception as e:
            resp = Response(json.dumps({'error': e.args}), status=500, mimetype='applcation/json')

    # Returns an error response because there is missing data in the payload.
    return Response(json.dumps({'error':'No token or payload data informed'}), status=400, mimetype='application/json')

# Checks if the `IS_HEROKU` variable is set. If it is (in our dyno) then the app is running on
# Heroku's cloud. Otherwise it is running locally in our machine, so we want it to run in our
# localhost, on port 8080 instead (and with debug mode active).
if not os.environ.get('IS_HEROKU', None) and __name__ == '__main__':
    app.run(host='localhost', port='8080', debug=True)
</code></pre>
<p class="slds-m-bottom_medium">And with this small web app hosted in Heroku we are not limited to a single URL. This transforms any POST request to a PATCH request. I’ve used this to call an Outlook endpoint (hence why the apps’ route was named /contacts/) but it can be renamed as needed.</p>
<p class="slds-m-bottom_medium">An idea would be to have all HTTP verbs available as endpoints, such as /post, /get, /delete, etc. This way the app will look more like an endpoint bus though…</p>
    </div>
</div>



            </div>

            <div class="slds-border_right slds-col slds-size_1-of-6">

            </div>
        </div>

        <div class="dgf-footer-space"></div>
    </div>
</body>

<!-- footer -->
<footer class="dgf-footer">
    <div class="slds-p-around_x-large slds-theme_default">
        <div class="slds-grid slds-p-top_small ">
            <div class="slds-col slds-size_1-of-3">

            </div>
            <div class="slds-col slds-size_1-of-3">
                <center>
                    <p>
                        <span class="slds-text-color_default">Copyright® Dogeforce Project Collaborators</span>
                        <span class="slds-text-color_weak">@ 2020-06-21</span>
                    </p>
                </center>
            </div>
            <div class="slds-col slds-size_1-of-3">

            </div>
        </div>
    </div>
</footer>

</html>